# Javascript
---
author: Jason Song <metaseed@gmail.com>
version: 1.0.0
tag: [duplicate,help wanted,good first issue,data]
subPage: [277,303,231]
enable: [toc]

---
"documents/276.md does not match 
0e9247c4349201b3afa82b0bc014b52686d3b981"
7a704f44327177246a25b43b627dfe2c6e46a6ff


'# Composing Software\n---\nauthor: Jason Song <metaseed@gmail.com>\nversion: 1.0.0\ntag: []\nsubPage: []\nenable: [toc]\n\n---\n\n*(.toc)*\n\n## [Introduction](https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea)\n> Composition: “The act of combining parts or elements to form a whole.” ~ *Dictionary.com*\n\n## Three kinds of function composition\n\n* embedded function call: f(g(h(j(a))))\n* method chaining: a.f().g().h()\n* function piping or combining:    \n   pipe(z,x,c)(a)\n\nFunction composition is the process of passing the return value of one function as an argument to another function. In mathematical notation:\n\n`(f ∘ g)(x) = f(g(x))`\n\nWe can call this kind of function composition as embedded function composition, it\'s not friendly to read or write.\n\nMethod chaining is the process of directly calling a method on the return value of a function, without needing to refer to the return value by name:\n\n```js {10}\nconst g = n => n + 1;\nconst f = n => n * 2;\nconst wait = time => new Promise(\n  (resolve, reject) => setTimeout(\n    resolve,\n    time\n  )\n);\nwait(300)\n  .then(() => 20)\n  .then(g)\n  .then(f)\n  .then(value => console.log(value)) // 42\n;\n```\n\n> If you’re chaining, you’re composing.\n\n## Higher Order Functions \n\n> A higher order function is a function that takes a function as an argument, or returns a function.\n\n### Reduce\n\n```js\nconst reduce = (reducer, initial, arr) => {\n  // shared stuff\n  let acc = initial;\n  for (let i = 0, { length } = arr; i < length; i++) {\n    // unique stuff in reducer() call\n    acc = reducer(acc, arr[i]);\n  // more shared stuff\n  }\n  return acc;\n};\nreduce((acc, curr) => acc + curr, 0, [1,2,3]); // 6\n```\n```js\nconst filter = (\n  fn, arr\n) => reduce((acc, curr) => fn(curr) ?\n  acc.concat([curr]) :\n  acc, [], arr\n);\n```\n\n```js\nconst map = (fn, arr) => arr.reduce((acc, item, index, arr) => {\n  return acc.concat(fn(item, index, arr));\n}, []);\n```\n\n```js\nconst compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);\n```\n> Note: pipe is from left to right\n\n### Step function \n```js\n// 2 step function\nconst trace = label => value => {\n  console.log(`${ label }: ${ value }`);\n  return value;\n};\n\ntrace(\'your name:\')(\'jason\')\n/*\nyour name: jason\n*/\n```\n```js\n// pipe(...fns: [...Function]) => x => y\nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\n```\n\n## Currying\n\n> **Currying**: A curried \nfunction is a function that takes multiple parameters one at a time: It takes a parameter, and returns a function that takes the next parameter, and so on until all parameters have been supplied, at which point, the application is completed and the final value is returned.\n```js\n// Tiny, recursive autocurry\n\n// version 1:\nconst currying = \n(f, ...a) => (...args)=> {\n    args = [...a,...args];\n    if(args.length === f.length) return f(...args);\n    return currying(f,...args);\n}\n\n// version 2:\nconst curry =\n (f, arr = []) => (...args) => (\n  a => a.length === f.length ?\n    f(...a) :\n    curry(f, a)\n)([...arr, ...args]);\n```\n```js\nconst add3 = curry((a, b, c) => a + b + c);\n\nadd3(1, 2, 3); // 6\nadd3(1, 2)(3); // 6\nadd3(1)(2, 3); // 6\nadd3(1)(2)(3); // 6\n```\nauto currying could be used to generate the pipable funtion. \n\n> when writing function with muti parameters, it would be better to make the main processed object the last parameter. \n\nto turn the methord on object to the pure function:\n```js\nconst str = \'abc def\';\nconst atrA = str.split(\' \');\n\nlet split = (seprator, str/*last*/) =>\nstr.split(seprator)\n// currying\nsplit = curring(split);\n\nconst strB = pipe(split(\' \'))(str)\n\ntrace(\'strA === strB\')(strA ===strB)\n```\nhttps://github.com/tc39/proposal-partial-application/blob/master/README.md\n\n> Writing functions without mention of the arguments is called **point-free style**. To do it, you\'ll call a function that returns the new function, rather than declaring the function explicitly. That means you won\'t need the `function` keyword or the arrow syntax (`=>`).\n\n```js\nconst firstChar = x => x[0];\nconst toUpperCase = x => x.toUperCase();\n// not pointfree cause we receive args\nvar initials = function(name) {\n  // OO programming: String -> Array -> StringArray\n  return name.split(\' \').map(compose(toUpperCase, firstChar)).join(\'. \');\n};\n\nconst split = sep => str => str.split(sep);\nconst map = func => arr => arr.map(func);\nconst join = conn => strArr => strArr.join(conn);\n//pointfree\nvar initials = compose(join(\'. \'), map(compose(toUpperCase, firstChar)), split(\' \'));\n\ninitials("I\'m writting your professional life");\n// \'I. W. Y. P. L\'\n```\nhttps://github.com/tc39/proposal-pipeline-operator/blob/master/README.md\n\n\n## Favor object composition over class inheritance\n* **The tight coupling problem**: Because child classes are dependent on the implementation of the parent class, class inheritance is the tightest coupling available in object oriented design.\n* **The fragile base class problem**: Due to tight coupling, changes to the base class can potentially break a large number of descendant classes — potentially in code managed by third parties. The author could break code they’re not aware of.\n* **The inflexible hierarchy problem**: With single ancestor taxonomies, given enough time and evolution, all class taxonomies are eventually wrong for new use-cases.\n* **The duplication by necessity problem**: Due to inflexible hierarchies, new use cases are often implemented by duplication, rather than extension, leading to similar classes which are unexpectedly divergent. Once duplication sets in, it’s not obvious which class new classes should descend from, or why.\n* **The gorilla/banana problem**: “…the problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” ~ Joe Armstrong, “Coders at Work”\nhttps://medium.com/javascript-scene/a-functional-programmers-introduction-to-javascript-composing-software-d670d14ede30\n\n\n\n\n### A Word on Redux\n\n```js\nreducer: (state: Any, action: { type: String, payload: Any}) => newState: Any\n```\n\n* A reducer called with no parameters should return its valid initial state.\n* If the reducer isn’t going to handle the action type, it still needs to return the state.\n* Redux reducers must be pure functions.\n\nredux reducers reduce on actions by time\n\n## [Functors & Categories](https://medium.com/javascript-scene/functors-categories-61e031bac53f)\nA **functor** data type is something you can map over. It’s a container which has an interface which can be used to apply a function to the values inside it. When you see a functor, you should think “*mappable*”. Functor types are typically represented as an object with a .map() method that maps from inputs to outputs while preserving structure. In practice, “preserving structure” means that the return value is the same type of functor (though values inside the container may be a different type).\n\nJavaScript’s built in array and promise objects act like functors. For collections (arrays, streams, etc…), .map() typically iterates over the collection and applies the given function to each value in the collection, but not all functors iterate. Functors are really about applying a function in a specific context.\n\nPromises use the name .then() instead of .map(). You can usually think of .then() as an asynchronous .map()method, except when you have a nested promise, in which case it automatically unwraps the outer promise. Again, for values which are not promises, .then() acts like an asynchronous .map(). For values which are promises themselves, .then()acts like the .chain() method from monads (sometimes also called .bind() or .flatMap()). So, promises are not quite functors, and not quite monads, but in practice, you can usually treat them as either. \n\nCategories have two important properties:\n\n* Identity\n* Composition\n\nSince a functor is a mapping between categories, functors must respect identity and composition. Together, they’re known as the functor laws.\n\n\n```js\nconst Identity = value => ({\n  map: fn => Identity(fn(value)),\n  // to + str or num\n  valueOf: () => value,\n  // inspect an Identity instance in the console\n toString: () => `Identity(${value})`,\n  constructor: Identity,\n  [Symbol.iterator]: function* () {\n  yield value;\n}\n});\n\nObject.assign(Identity, {\n  toString: () => \'Identity\',\n  is: x => typeof x.map === \'function\'\n});\n```\n```js\n// trace() is a utility to let you easily inspect\n// the contents.\nconst trace = x => {\n  console.log(x);\n  return x;\n};\nconst u = Identity(2);\n// Identity law\nu.map(trace);             // 2\nu.map(x => x).map(trace); // 2\nconst f = n => n + 1;\nconst g = n => n * 2;\n// Composition law\nconst r1 = u.map(x => f(g(x)));\nconst r2 = u.map(g).map(f);\nr1.map(trace); // 5\nr2.map(trace); // 5\n\n// +\nconst ints = (Identity(2) + Identity(4));\ntrace(ints); // 6\nconst hi = (Identity(\'h\') + Identity(\'i\'));\ntrace(hi); // "hi"\n\n// [Symbol.iterator] enables standard JS iterations:\nconst arr = [6, 7, ...Identity(8)];\ntrace(arr); // [6, 7, 8]\n```\n```js\nconst fRange = (\n  start,\n  end\n) => Array.from(\n  { length: end - start + 1 },\n  \n  // change `Identity` to `start.constructor`\n  (x, i) => start.constructor(i + start)\n);\nconst range = fRange(Identity(2), 4);\nrange.map(x => x.map(trace)); // 2, 3, 4\n```\n\n```js\n// Using an arrow function as the map function to\n// manipulate the elements\nArray.from([1, 2, 3], x => x + x);      \n// [2, 4, 6]\n\n\n// Generate a sequence of numbers\n// Since the array is initialized with `undefined` on each position,\n// the value of `v` below will be `undefined`\nArray.from({length: 5}, (v, i) => i);\n// [0, 1, 2, 3, 4]\n```\n```js\n// Create the if Exists functor: kick off a chain of operations, but only if the value inside the functor is not undefined or null?\nconst exists = x => (x.valueOf() !== undefined && x.valueOf() !== null);\nconst ifExists = x => ({\n  map: fn => exists(x) ? x.map(fn) : x\n});\nconst add1 = n => n + 1;\nconst double = n => n * 2;\n// Nothing happens...\nifExists(Identity(undefined)).map(trace);\n// Still nothing...\nifExists(Identity(null)).map(trace);\n// 42\nifExists(Identity(20))\n  .map(add1)\n  .map(double)\n  .map(trace)\n;\n```\n  '