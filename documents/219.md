# Event loop: microtasks and macrotasks
---
author: Jason Song <metaseed@gmail.com>
version: 1.0.0
tag: []
subPage: []
enable: [toc]

---

> reading note: https://javascript.info/event-loop

## Event Loop
```js
while(true) {
    const task =  getTaskFromMacrotaskQueue();
    if(task)
        executeTask(task);
    else
        sleep();
}
```
![=*200](https://javascript.info/article/event-loop/eventLoop.svg)
### Examples of tasks
*  `<script src="...">`loads, the task is to execute it.
* a user moves the mouse, the task is to dispatch mousemove event and execute handlers.
* the time is due for a scheduled setTimeout, the task is to run its callback.

> Attention    
> >     Rendering never happens while the engine executes a task. It doesn’t matter if the task takes a long time. Changes to the DOM are painted only after the task is complete.      
>
 > >     If a task takes too long, the browser can’t do other tasks, such as processing user events. So after a time, it raises an alert like “Page Unresponsive”, suggesting killing the task with the whole page. That happens when there are a lot of complex calculations or a programming error leading to an infinite loop.

## Macrotasks and Microtasks
Microtasks come solely from our code. They are usually created by promises: an execution of .then/catch/finally handler becomes a microtask. Microtasks are used “under the cover” of await as well, as it’s another form of promise handling.

There’s also a special function queueMicrotask(func) that queues func for execution in the microtask queue.

> Immediately after every macrotask, the engine executes all tasks from microtask queue, prior to running any other macrotasks or rendering or anything else.

![=*400](https://javascript.info/article/event-loop/eventLoop-full.svg)