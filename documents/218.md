# Web Component
---
author: Jason Song <metaseed@gmail.com>
version: 1.0.0
tag: []
subPage: []
enable: [toc]

---
> reading note: https://javascript.info/web-components

https://javascript.info/mutation-observer

## Custom elements
* Autonomous custom elements – “all-new” elements, extending the abstract `HTMLElement` class.
* Customized built-in elements – extending built-in elements, like a customized button, based on `HTMLButtonElement` etc.

```js
class MyElement extends HTMLElement {
  constructor() {
    super();
    // element created
  }

  connectedCallback() {
    // browser calls this method when the element is added to the document
    // (can be called many times if an element is repeatedly added/removed)
  }

  disconnectedCallback() {
    // browser calls this method when the element is removed from the document
    // (can be called many times if an element is repeatedly added/removed)
  }

  static get observedAttributes() {
    return [/* array of attribute names to monitor for changes */];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // called when one of attributes listed above is modified
  }

  adoptedCallback() {
    // called when the element is moved to a new document
    // (happens in document.adoptNode, very rarely used)
  }

  // there can be other element methods and properties
}

// let the browser know that <my-element> is served by our new class
customElements.define("my-element", MyElement);
// We also can document.createElement('my-element') in JavaScript now.
```

```html
<script>
class TimeFormatted extends HTMLElement { // (1)

  connectedCallback() {
    let date = new Date(this.getAttribute('datetime') || Date.now());

    this.innerHTML = new Intl.DateTimeFormat("default", {
      year: this.getAttribute('year') || undefined,
      month: this.getAttribute('month') || undefined,
      day: this.getAttribute('day') || undefined,
      hour: this.getAttribute('hour') || undefined,
      minute: this.getAttribute('minute') || undefined,
      second: this.getAttribute('second') || undefined,
      timeZoneName: this.getAttribute('time-zone-name') || undefined,
    }).format(date);
  }

}

customElements.define("time-formatted", TimeFormatted); // (2)
</script>

<!-- (3) -->
<time-formatted datetime="2019-12-01"
  year="numeric" month="long" day="numeric"
  hour="numeric" minute="numeric" second="numeric"
  time-zone-name="short"
></time-formatted>
```

> Custom elements upgrade   
If the browser encounters any `<time-formatted>` elements before `customElements.define`, that’s not an error. But the element is yet unknown, just like any non-standard tag.
Such “`undefined`” elements can be styled with CSS selector `:not(:defined)`.
When customElement.define is called, they are “upgraded”: a new instance of TimeFormatted is created for each, and connectedCallback is called. They become :defined.
To get the information about custom elements, there are methods:
customElements.get(name) – returns the class for a custom element with the given name,
customElements.whenDefined(name) – returns a promise that resolves (without value) when a custom element with the given name becomes defined.