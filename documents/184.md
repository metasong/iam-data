# S language design
---
author: Jason Song <metaseed@gmail.com>
version: 1.0.0
tag: [S-Lang]
subPage: [181]
enable: [toc]

---
## Comment
```S
// online comment
/* mulitple
line comment */
```
## Primitive Types
```S
i8 i16 i32 i64 i128 isz // isize pointer-sized signed integer
int // polymorphic int, width determined later
// This works with any integer
// int<a>
sdd1(x: int): int { x + 1}
u8 u16....
f16 f32 f64
char // 32-bit Unicode scalar value.
str // UTF-8
bool
```

### auto promotion
```S
   i8 → i16 → int → i64
                  ↘     ↘
                    f32 → f64
                  ↗     ↗
   u8 → u16 → u32 → u64 ⬎
      ↘     ↘     ↘      ptr
   i8 → i16 → int → i64 ⬏
```

### Literal of primitive Types
```S
// integer
128i32 1.2f64
128 + 3i16 // polymorphic 128 determined to be i16
5i32 + 7i16 // 7 auto promotedto i32
54_000_000_u64 // digital separator


// IEEE 754 float
3.14 3. 
// polymorphic 
// has the type `Float a` until it is later used in an expression
// which forces it to be either a F32 or F64.
print 3.14 // finally not concreted, so f64

'c' // char
'abc' // literal str 
"hello world!"
"${exp}bc$exp followed by space or other char not allowed in name" // interpolable str 
"\n \$ \\ \t \x61 is a; \### is octal \141 is a" //
"\u2605" // unicode ★
// str can not be indexed directly, need to .bytes to get the under byte array

true false
```

## Variable
### Declearation, initialization and assignment
variable has two attribute: type and value
```S
: is the bind operator, to bind value and/or type
= is the setValue operator to mutate the value or set default value of parameter
```
```S
a:1i32 // desugur into:
let a:i32=1 // let: declearation
// : is new and init
let a // declear a variable with its type infered by following usage.
// declear and assignment
a:7i32 //declear a and 7 is initial value: a:i32, type is infered
// := operator is used for content assignment
B:5i33
B=4
// have to be decleared before assign
c=4i32// error:  not decleared
a = 6i32 ; A=5 // assignment to an already declared  uninitialized variable or mutate a initialized mutable variable

// allow variable overriding
a:3 // declear a,  3 is int if not 3i64; desugur into let a = 3
 
a:6 // error: override the  declearation with a new declearation of the same name in same scope
{
    a:7 // new overriding previous declearation in the sub block scope
}
// unused variable: warning in dev mode, error in prod mode
```
### array initialize
```S
a: [1,2,3] // array
b:list[1,2,3]
```

### imutable, mutable and const
```S
const CONST_GLOBAL:mustInitiallizedWithCompileTimeConstExpression // implicitly imutable, static lifetime
a:anyExpressionIncludeRuntimeValues // explicityly imutable, same life time as the enclosing scope

A:i32 // mutable variable in scope is upcase
// s allow global runtime variable, rust has static variable, it's compile time global variable
// S constrain global variable/const with BIG_CASE_NAME, otherwise a compile time error

```
### lazy initialization
```S
lazy a: runtimeExpressionExecutedWhenFirstTimeUsing
//  avoid paying the initialization cost when the program starts if they won't be needed.
```
### reference

## flow control
### conditional expression
```S
condition?expression
condition?expression:expression
```
?: isTrue operator
::  isFalse operator

this design compatbale with ?: expression
```S
// problem can not use declear assignment inside ?:
b:3
{
     a > 1 
     ? b:5 // error: thinking ':' as else instead of init
     : 4
 }
// solution use `~` as else instead of the `:`.
// another solution is use := as the init operator, 
// so we can continue using `:` as the else operator,
// but we realy like the concise of the `:` as the init operator, just like we use it in the type constructor
// the dragback: the bitlogic operator of ~ can not be used, 
```

```S
   condition 
   ? isTrue expression arm
   ~ isFase expression arm
```
```S
   if(a>100){}
   a>100?{}
   if(a>100){}else if(a<10){} else{}
 a>100?{}~a<10?{}~{}
```
 ```S

 // the ?: must com in pair, otherwise: what is the : associate with?
a>100 
? b<2 
? 3
: 4
// is it:
a>100 
? b<2 
    ? 3
    : 4
// or
a>100 
? b<2 
    ? 3
: 4

// if else has similar problem
if(a>100) if(b<2) 3 else 4

// the problem is we allow if without the 'else'
// to solve this problem
// always pair the ? with :, and the empty : when no else

// anothor way
?condition{true_arm}: false_arm

// the it will be
a>100 
? b<2 
    ? 3:
: 4
// but it also has problem
a>1?3:
b:3+4
// solution is pair : with ;


 ```
### loop
#### loop expression


```S
condition?expression\
// \: loop operator

expression\condition

i=1; b=2

// while:
k= i++<10 ? {
    b+=2;
    b>6 ? break 7;
}\

// do while:
k= {
    b+=2;
    b>6 ? break 7 : yield b
}\i++<10;

// constant loop
k={
b+=2
b>6?break 7
}\

k=i++<10？b++\

```
loop expression may return 2 type of objects, enumerable, value or both.
### enumeration expression
> not use this design: it requires space before afert %, we chose the design of implicit variable $, $i

```S
   IEnumrable %v 
         expression
         
  IEnumrable i%v 
         expression
         |>expression
         |>expression
                    
               
```   
`return`, `yield`, `continue` and `break` in expression:
  * `break`: break the loop
  * `continue`: end this loop, and continue next loop
  * `yield`: yield one value to the result enumrable, and continue excution. we could yield several value to the result in one loop.
  
  * `return`: return of the parent function
  * `yield return`: yield value to parent function. used for enumeratable computation
  
  for simple for loop
```js
  for(int i=0;i<100;i++) {}
  for(int i=0;i<100;i=i+2) {}
  for(let a of enumberable) {}
  for(let i,a of enumberable){}
```
> $$ is curent Item  
> $i is current index

> $l , $r when write custom code for expression, left and right
```S
0..100 % {/*$$*/}
0..2..100 % {/*$$*/}
enumberable % {/*$i, $$*/}

//we reserve the @ for @ Bindings in pattern match
//  the math % operator for mod , overload it for ienumerable.
// contex for operator: $$, $i, $l, $r
```

### Implicit var
```S
IEnumrable % $i>7?$$
```

## function
### signature
```S
func: (a:i32,b:i32)->i32 = a+b
// suggers
funcA(a:i32,b:i32)->a*b
funcA1(a:i32,b:i32)->i32 a*b
funcB(a:i32,b:str)->i32 {return 3+5}
funcC(a:i32,b:str)->(c:i32,d:f32) {c = 3; d = 5;}
func(a:i32, b:6, c:"abc", d:f32)-> (r1:i32, r2:f64, r3:str) {}
```
### parameter init

```S
// init by position
func(3,d:3.14)
// init by position then name 
func(3,d:3.14)
// init by name
func(3,d:3.14)
```
### return value designment
```S
// by position
(v1,v2) = func(3,d:3.14)
// by position then name 
(v1,v2:r3) =func(3,d:3.14)
// by name
(r1:, r2:) = func(3,d:3.14)

// design: func1(...)
// () needed even if no argument
// `func arg1, arg2 .property`
// vs
// `fuc(arg1, arg2).property`
//
// `fuc().pro` vs `fuc.pro`
// there may property on fuc obj

func(a:i32, b=3.4f32, ...c)
```
```


: :is of type
->: reuturn as type
=: assign the value
=>: not used
```

### function signature infer from expression
lambda function: 
s function
```S
// auto scope to where a function defination is good.
// one line: out most expression 
to deduce the parameters
func1: $0 + 4 * $0 
func11: x,y->x+4y
func2: $0^2+2$1+1
x=>x^2+2x+1
//multiple  line:
${// within the block we will infer out a function
func1($,5,$);
func2($)
}
```
string interpolation we will use % ?

### clousure variables sugar
```S
func(a:i32) -> c:i32 -> a+c
fn1: fuc(3)
// the same as
@[closure(a:3i32)]
fn1(c:i32)->a+c
// 'a' is state variables in the parent scope only for the function
// store states, so the function is not pure.
fn1(4)
```
### pipe operator
https://github.com/tc39/proposal-pipeline-operator
based on the S function



## Type
```S
&: reference to const
&var:  reference to variable

type A(a:i32,b=6.1f32,c="song")
// a's default value is zero of type, here is 0.
// a type is defined with all default value of it's fields.
// a block of mem, with every member accessed by index, but with specific member accessed by name
```

```S
memberType is either explicit or defered from defaultValueLiteral
// declear
type Name // desuger into typeName()
type Unit() // we have to use this to define unit type in tagged unin, otherwise it is reference of type defined somewhere.
type Name(i32,str)
type Name(a:i32,b=1.2f32)
// = default value
type Name(i32,str,d:i32,e1.2f64)
Name(3,"fff",d:4,e:7)
//: : of type or init as
//= : assignment or default value
// type alias and part type
type A = B // type alias of B

// use pattern to define part type
type bool = true | false
type F = 3|5|6.2
type C = i32(4) // 
type D = i32(1..=5)
type E = i32(<5) 
type FG = >=60i32
type Colors = Red(0xff0000)|Yellow(0xffff00)
// enum of rust
type G = A(i32,b=7i64)|D|L(f=6.2F)|U()
// we could not use b:7i64, it's pattern match if b to match 7i64, here b's default value is 7.

 // directly use subtype to define type
 type FFF(a:3..6,b:A|B(i32,f64))
// D is defined some where then use it, if not creat it with D() 

// U is unit type defined here


// construct on stack
let a = Name(1,3)
// access
let b = a.1 // by index
let c = a.c // by name
// construct on heap
a: &Name(1,3)

fn Func1(a:i32, b:3.4, c="yes", d=5u64, e:f64)
// a,e required parameter
// b, c, d: optional parameter with default value
// default value= : value[type]
Func1(3,c="no",e=6.0)
// a is the required parameter can be assigned by position.
// e is the required parameter, after optional parameter, value should be assigned by name.
// assignment rule: position... name...
// 
```
### member visibility
```S
// private member (func and field) start with _
type A(_a:int, b:5i32)
// type _B() //no such for module level
// we exp at module level explicitly in the mod.s
```
> compatable with function parameter design
> the function can be viewed as an expression with a anonymous type a parameter
### constructor
```S
//requirement: constructor param with default value must after the one without defaut value, otherwise the required paramter after the optonal one can only be assigned via name, means not possible via position
// need this constrain??

type A(readOnly: i32, Mutable: Str, _private: i32, _PrivateMutable: [i32], a=5i32) {
 _privateMemb: i32
 publicMemb: f32
 func(){
 
 }
 {
// init logic
 }
}

```
### Destructor
> via pattern match
```S
(positinalPubMemberInCstorB, optionalPubMemberInCstorC, pubMemberInsideBody: d) = a;
```

### member access
```S
a.1
b.member
// can not 
c.expression
// the location is determined at compile time, name and position is not stored in runtime
// but we can access array with expression, the location is consecutive and every item of same size:
a[expression]
```
### member logic
```S
MemberLogic: {
expression |
function defination
...
}

(
varA:i32,
funcA: (a:i32,b:i32)->a*b,
)
// or give it a name
Type A(
varB: i64,
varA: 3i32,
funcD: a:i32->a*5,
)

type A(a:i32,b=6.1f32,c="song") {
  funcC: (bb:i32,dd:str)->(c:i32,d:f32) {
  // can not just use '.':
  // i.e. 
  // a.b  // user may use a new line for long line
  //  .c //c of b or 'this obj'?
  // so we use $, it's a longs on the column: huabiao
  // another cause: can not use 'this obj' i.e. in str interpolation, in operator overloading
    $.a = bb
    dd = $.c; // access of 
  }
}
// func call: a.func()
// when compiled to C, the first parameter is the $: _s_
// outside the type body
A.func(){}
```
### Discriminated Unions
```S
DiscriminatedUnions: type TypeName = SubTypeSymbol ('|'SubTypeSymbol)*[{memberLogic}] 
SubTypeSymbol: SubTypeName|Type
[...]: optional repeat

// Type is defined in scope.
for a sybTypeSymbol: if not defined in scope, it's a subtype name and we create a subtype
```
## Unit type

```S
type Red
type Color = Red | Blue | Yellow
// Blue and Yellow is new unit type
// desugur
type Color = Red | Blue() | Yellow()

a: Red
// desugur 
a: Red = Red()

type BinTree = Node(BinTree,BinTree) 
                           | Tip
// tip is not find, desugur into Tip() to creat a new type


```
#### implement
add first field to identify the subtype, 
at compile time alocate a number to identify. 0, 1, 2, ..
the declearion file generated contains info that identify the cororesponding dll

the compiler will check the link, just in case of mismatch.

#### compile time  type convert
```S
prism(color: Collor)-> i32 

c: Blue
prism(c)
// details
prism(Color(c))
// Color is a union, need runtime info to discriminate sub type

```
### Funciton Member
```S
type A (a:int32,B:6i32){
    func()->3
}
A.funcA()->4
```

## Array, List and Map
### Array
```S
a: i32[] // type
a: i32[3] // value
a: [1,2,3]i32[]
// the array's capacity==length is fixed, it is allocated on stack
//
```
### List
```S
a: [i32]() // empty list
a: List<i32>() // same as above
b: [1i32, 2, 3]
//
// can avoid realocation if we already know the max capacity

type List<T>(cap: i32,  default(T)) {
    len: i32
    _data: *T
}
c: [i32](500)

```
###  index range
```S
type Range(startIndex: i32, stopIndex: i32, stepSize: i32 = 1)
a: [1,2,3,4]
1..=4 // 1,2,3,4
1..4 // 1,2,3
'a'..='z'
0..=-1
..
-1..0 // step size 1
a[-1..=0] // [4,3,2,1]
1..2..8 // 1,3,5,7
1..2..=8 // 1,3,5,7,8
'a'..'e' // a, b,c,d
```
### list comprehension
```python
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x for x in fruits if "a" in x]
```

```S
// variable pattern and in pattern
[...(fruits% #x&('a' in x) ?x)]
// variable pattern and 'and' condition
[...(fruits% #x&&(x.include('a')) ?x)]
```
### content operator
```S
:= : content assignment
// can not use :+ and :-, collide with initiate with number

// content add: insert, append, prepend
// should use += instead the design of :< (append) >: (prepend)

+=(left:collection<T>, right:(itemPattern: Pattern, index:int32, times: int32))

str += 'c' //content append
queue += msg 
+= ItemOrIenumrable<Item>,index:-1, times: 1  return enumerable
str += 'a' += 'b'
//+= insert
str += 'c',0 // prepend
// >: prepend // i=0
str += 'c',times:5 //"ccccc"

// content extract: remove, pop, dequeue
str:> : remove all

-=:  item:_, index: -1, times:1
 -=(left:icollection<T>, right:(item:&T, index:int32, times:int32))
// item is a pattern match
// return modified collection
a: queue-=&b,0 // dequeue
a: stack-=&b // pop
// clear
collection -= times:-1

// str <: c // dequeue

str := "ggg"
it>>col // prepend
col<<it // append
```
## Map
```S
[str: i32]
type Map<K, V>()
// 
a: [i32:f32] = [1: 3.2, 4:6.7]
```

## Module
```S
imp filePath, directoryPath
exp 
```
in file
```S
exp type A()
type B()
exp B
```
in mod.s of folder
```S
exp 
```

## Pattern Matching

> pattern matching: recognize the pattern and mach to it
example:
```S
a#[a,b]?expression
recognize pattern: collection pattern, length >= 2
match: a is the first, b is the last
a#[b,c,len:5] length == 5, literal pattern

a:[i32:i32]()// empty map

```

### destruction when assignment
> it's pattern match statement

```S
// patternWithVariable = valueExpression
// compiler error if the pattern is not match
```
#### variable initiallization or assignment in pattern
```S
(a, b:c, d=e) = h 
// new variables: a, c. e is a previously decleared varaible, 
// a is by position new variable is the same as :a; ':a' is explicitly new by position, '=a' is explicatly assigment by position
// a: is a:a; b= is b=b
```
```S
// by position
(0:b,4=c,5..10:a)=d
```
```S
// pattern match
(x:_): a type with a member named as x
(x:_,len:1): a type with a member named as x
(x): a type with first member and assigned to x
(x,len:1): a type with only one element, and match it to variable x
```
    

### pattern match operator
> it's pattern match expression

```S
// variable#pattern
// #: pattern match operator that return booleanValue

b: variable# (a,c) // return boolean if match, and when matched, assign value to a,c
// try to match to the type that has 2 items; a: first item in type; b: second item in type;

```

```S
type Some(i32)
let num = Some(4)
a: num#Some(x)&&x%2==0?x:-1
```

#### pattern match with case-arms
 ```S
a# >100?{};   
a# >100?{}|<10?{}: {}
```

```
 var#pattern   ?if expression arm
    |pattern   ?{if code block expression arm}
    |pattern   ?if expression arm
    |pattern LogicConditionExpression  ?if expression arm
    :else expression arm
```  
  
```
   var usually is a discriminated union defined with '|'
   |: discrimination case or: continue pattern match for var, == ':var#'
   ?: condition?expression: if expression operator
   :: else expression operator
   ;: expression end symbol: end of the pattern match without else
   && and ||: lazy boolean expression operator
   & and |: 'and' and 'or' pattern mach oparator
```
### enumrable pattern match
```S
//IEnumrable [i]%[v]#pattern ... 
// 
   IEnumrable % #pattern ? expression
               |pattern ? expression
               |pattern ? expression
               :expression
 //expand to
  IEnumrable i%v v#pattern ? expression
               |pattern ? expression
               |a @ pattern ? expression
               |Type(c:v@1..=8)? v++
               :expression  
```

### # operator vs = operator
```S
func(...) # (a,(c:d))
// unmamed struct (tupple) pattern, variable pattern
created 2 variables
It's a pattern match expression returned bool, but not used
// a and d is new variable
// : is the as operator to creat a new variable and assign initial value
// =  is operator to assign a value to variable already created.
// we first call then use the value, easy to input and support fluent intelligence, mind model, but it accept match fail, if input is not matching


(a,(c:d)) = func(.....)

// '=' assignment match which guards the right destruction with compile time for type match, and runtime value match.

```

### patterns
#### as operator
```S
pattern: initNewVar // mut or readonly
pattern= setMutVar
```
#### type patterns
```S
A
A: a // init new var a
A = a // set a
```
> when in assignment, checked in compile time
#### value member pattern: 
(a:x, y, b=z)
 
##### List pattern design
> Set | List {index}:Collection(count):IEnumrable

   [a,b,4..^4c,w,..f,6d,e]
   scan from start then from end to fix every position
   any object that has
   
  patternMatch(pattern:str):bool

#### value patterns
> when in assignment, 
> when the value is know, checked in compile time.
> otherwise checked in run time
##### literal value pattern
1
2i32
2|3
##### relational pattern
>, <, >=, <= value literal
```S
>4:v
>4=v
```
> no ==, because we directlay use he literal value pattern
> only compair  value literal, to compair with variable
(a:x) && x>b
##### in range pattern
the literal range

```S
in(1..7)
in('a'..='z')
```






