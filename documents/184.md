# S language design
---
author: Jason Song <metaseed@gmail.com>
version: 1.0.0
tag: [S-Lang]
subPage: [181]
enable: [toc]

---
> pattern matching: recognize the pattern and mach to it, action
example:
```
[a,b]?action
recognize pattern: collection pattern, length is 2
match: a is the first, b is the last
```
> pattern match is destruct
```
variable# (a,b)
```
unmamed struct (tupple) pattern, variable pattern
created 2 variables
It's a pattern match expression returned bool, but not used

## Pattern Match Design
real grammar:
```
 var#pattern   ?if expression arm
    |pattern   ?{if code block expression arm}
    |pattern   ?if expression arm
    |pattern LogicConditionExpression  ?if expression arm
    :else expression arm
```  
  
```   
   #: pattern match operator
   |: discrimination or: continue pattern match for var, == ':var#'
   ?: condition?expression: if expression operator
   :: else expression operator
   ;: expression end symbol: end of the pattern match without else
   && and ||: lazy boolean expression operator
   & and |: 'and' and 'or' pattern mach oparator

```
```
type Some(i32)
let num = Some(4)
num#Some(x)&&x%2==0?x
```
   
   this design compatbale with ?: expression
   
```
   condition ?if expression arm
            :else expression arm
``` 
   ```
   if(a>100){}
   if(a>100){}else if(a<10){} else{}
   ```
 ```
 a>100?{};
 a>100?{}:a<10?{}:{}
 ```
   
   ```
a# >100?{};   
a# >100?{}, <10?{}: {}
   ```
## index range

1..4
1..^1
1..8\2: 1, 3,5,7
'a'..'j'

## collection pattern design
   [a,b,4..^4c,..f,d@6,e]
   scan from start then from end to fix every position
   
   
   any object that has
   
  patternMatch(pattern:str):bool
   
   
## enumeration expression


   ```
   IEnumrable v@i 
         expression
         
  IEnumrable v@i 
         expression
         |>expression
         |>expression
   
   IEnumrable v@i pattern ? expression
               |pattern ? expression
               |pattern ? expression
               :expression
               
 
 //IEnumrable [v]@[i]#pattern ...
 //expand to
  IEnumrable v@i v#pattern ? expression
               |pattern ? expression
               |pattern ? expression
               :expression             
               
  ```   
`return`, `yield`, `continue` and `break` in expression:
  * `break`: break the loop
  * `continue`: end this loop, and continue next loop
  * `yield`: yield one value to the result enumrable, and continue excution. we could yield several value to the result in one loop.
  
  * `return`: return from the parent function
  * `yield return`: yield valut to parent function.
  
  for simple for loop
  ```
  for(int i=0;i<100;i++) {}
  for(int i=0;i<100;i=i+2) {}
  for(let a of enumberable) {}
  for(let i,a of enumberable){}
  ```
  ```
0..100 @ i? {}
0..100\2 @ i? {}
enumberable @i a? {}
  ```
### conditional expression
```
condition?expression
condition?expression:expression
```
?: if-then operator
:: else operator
### loop expression
```
condition?expression\

expression\condition

i=1; b=2

while:
k= i++<10 ? {
    b+=2;
    b>6 ? break 7;
}\

do while:
k= {
    b+=2;
    b>6 ? break 7 : yield b
}\i++<10;

k={
b+=2
b>6?break 7
}\

k=i++<10ï¼Ÿb++\


```
\: loop operator

loop expression may return 2 type of objects, enumerable, value or both.


### list comprehension
```python
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x for x in fruits if "a" in x]
```

```
// variable pattern and in pattern
[...(fruits@ x&("a" in x) ?x)]
// variable pattern and 'and' condition
[...(fruits@ x&&(x.include("a")) ?x)]
```
## Type
```
Type: type Name[([memberName':'][memberType][[defaultValueLiteral][type]]@1[,...1])][{memberLogic}] 
memberType is either explicit or defered from defaultValueLiteral
// declear
type Name
type Name(i32,str)
type Name(a:i32,b:1.2f32)
type Name(i32,str,d:i32,e:1.2f64)


// a block of mem, with every member accessed by index, but with specific member accessed by name

// construct
let a = Name(1,3)
// access
let b = a.1 // by index
let c = a.c // by name

fn Func1(a:i32, b:3.4, c: "yes", d:5u64, e:d64)
// a,e required parameter
// b, c, d: optional parameter with default value
// default value: :value[type]
Func1(3,c:"no",e:6.0)
// a is the required parameter can be assigned by position.
// e is the required parameter, after optional parameter, value should be assigned by name.
// assignment rule: position... name...
// 
```


> compatable with function parameter design
> the function can be viewed as an expression with a type a parameter

### operator
:= : content assignment
:+ : content append
:+ "str",0 :insert
+: prepend
:- : remove all
:- item, start:false, times: -1



str := "ggg"


## Type Pattern Match
```S
(x:_): a type with only member named as x
(x:_,..): a type with a member named as x
(x): a type with only one element, and match it to variable x
```

## Discriminated Unions
```
DiscriminatedUnions: type TypeName = SubTypeSymbol ('|'SubTypeSymbol)*[{memberLogic}] 
SubTypeSymbol: SubTypeName|Type
[...]: optional repeat

Type is defined in scope.
for a sybTypeSymbol: if not defined in scope, it's a subtype name and we create a subtype
```

```
type BinTree = Node(BinTree,BinTree) 
                           | Tip
```

## member logic
```
MemberLogic: {
expression |
function defination
...
}
```

## object
```
con constant
mut variable

&: reference to const
&var:  reference to variable

type A(a:i32,b:6.1f32,c:"song")
// a's default value is zero of type, here is 0.
// a type is defined with all default value of it's fields.

```

## function
```S
(
varA:i32,
funcA: (a:i32,b:i32)->a*b,
funcA1(a:i32,b:i32)->a*b
funcB: (a:i32,b:str)->i32 3+5,
funcB(a:i32,b:str)->i32 {return 3+5},
funcC: (a:i32,b:str)->(c:i32,d:f32) {c = 3; d = 5;}
)
// or give it a name
Type A(
varB: i64,
varA: 3i32,
funcD: a:i32->a*5,
funcA: (a:i32,b:i32)->i32  a*b,
funcB: (a:i32,b:str)->i32  a++,
funcC: (a:i32,b:str)->c:i32,d:f32 {c=3; d= 5;}
)
// 
fn func(a:i32, b:6, c:"abc", d:f32)-> r1:i32, r2f64, r3:str {
// assigned by position
var v1,v2  =func(3,d:3.14)
// assigned by position then name 
var v1,v2:r3 =func(3,d:3.14)
// by name
var :r1, :r2 =func(3,d:3.14)
// assignment rule: position... name...

// design: func(arg...) () needed even if no argument
// fuc arg1, arg2 .property
// vs 
// fuc(arg1, arg2).property
//
// fuc().pro vs fuc.pro
// there may property on fuc obj

```
::is of type
->: reuturn as type
=: assign the value
=>: define expression


#### function signature infer from expression



```
[state(p1:i32, p2:5.3)]
fn fn1(a:i32)->5*a
// p1, p2 are state variables only for the function fields on the function object, store states, so the function is not pure.


```



### pipe operator
https://github.com/tc39/proposal-pipeline-operator


