# S language design
---
author: Jason Song <metaseed@gmail.com>
version: 1.0.0
tag: [S-Lang]
subPage: [181]
enable: [toc]

---
## Comment
```S
// online comment
/* mulitple
line comment */
```
## Primitive Types
```S
i8 i16 i32 i64 i128 isz // isize pointer-sized signed integer
Int // polymorphic int, width determined later
// This works with any integer
// int<a>
sdd1(x: Int)-> Int { x + 1}
// unsigned int
u8 u16....
u16 u32 u64
Flt // polymophic float
Num // polymophic number flt or int
chr // 32-bit Unicode scalar value.
str // UTF-8
bool
```
```S
// polymophic <>
// polymophic type is fixed when it was used in expression
// polymophic
`Int = <i8|i16|i32|i64|i128>
`Unt = <u8|u16|u64|u128>
`Flt = <f16|f32|f64>
`Num = <Int|Unt|Flt>
// partial-polymophic
`A<T> {
    a: T
}
```

```S
// pointer(address) is only allowed in unsafe context

```


### Number Auto Promotion
```S
   i8 → i16 → i32 → i64
      ↘     ↘     ↘
        f16 →f32 → f64
      ↗     ↗     ↗
   u8 → u16 → u32 → u64 ⬎
      ↘     ↘     ↘      ptr
   i8 → i16 → int → i64 ⬏
// type is the encoding rule of value or layout of memebers

// a polymofic value is value with its type not determined, need to be determined within the context. 
```


### Literal of Primitive Types
```S
// type post-decorator for number
128 //the same as 128num
128.2 // the same as 128.2flt
128i32 1.2f64
128 + 3i16 // polymorphic 128 determined to be i16
5i32 + 7i16 // 7 auto promotedto i32
54_000_000_u64 // digital separator

// IEEE 754 float
3.14 3. .3 // 3. or 3 is the same as 3num
// polymorphic 
// has the type `flt a` until it is later used in an expression
// which forces it to be either a f32 or f64.
func(a:f32)
func(3.14) // f32

true false
```

> polymophic vs unioned type
> polymophic is one type whose type is not clear at the moment but will be fixed at the time of using
> unioned type means the type that can be any one of the decleared types
### char and string
```S
'c' // char
"\n"
'cbc;'// literal str 
'ab''c' // ab'c
'hello world!'

// interpolable str 
"${exp}bc$exp followed by space or other char not allowed in name"
// we us {} means inside it we can write a lot expression and finally return a result
"\\ \" \$ \n \t \x61 is a; \### is octal \141 is a" //
"\u2605" // unicode ★
// str can not be indexed directly, need to .bytes to get the under byte array

// ": interpolition and \x
// ': literal string
```

## Variable
### Declearation, initialization and assignment
variable has 3 attributse: type, value(mem location(stack;heap), encording) and lifetime(scope)
ref type is on heap, value type corresponding the memlocation, it's inline type, can be on heap(i.e. as a mem field of a ref type) or stack
```S
if we just use = for both declearation and mut, we can not declear the same var in nested scope. becaue it is considered as mut. in other worlds, we need to diferentiate init and mut

: is the bind (declearation) operator, to bind initValue and/or type, after bind the type can not be changed, but the value can be changed if it's a mutable variable (start with Captial letter)
: is also the `as`(bind) operator in pattern match.

: is the `else` operator after condition test, we may replace it with the `~`, for simplicity of the language grammar

= is the setValue operator to mutate the value or set default value of parameter
```
```S
// : is bind operator, used to declear a new var and bind the type, we use = to init or mut value

a:1i32 
// desugur into:
aa:i32 = 1 
// pattern match explaining
variable pattern, then type pattern

//not used let: declearation 

a = 1 // = (mut operator) can be used for init (first mut) or mut the value.
a_ = 2

// one line
a:int b:2 c:3

//// = used in function default value too
// default use : too
b:f64 = a // implicit value converter

c:a as f64
b = a as f64 // explicit value converter

// : is new and init
// let a // declear a variable with its type infered by following usage.
// declear and assignment
a:7i32 //declear a and 7 is initial value: a:i32, type is infered
// := operator is used for content assignment
B:5i33
B=4
// have to be decleared before assign
c=4i32// error:  not decleared
a = 6i32 ; A=5 // assignment to an already declared  uninitialized variable or mutate a initialized mutable variable

// allow variable overriding
a:3 // declear a,  3 is int if not 3i64; desugur into let a = 3
 
a:6 // error: override the  declearation with a new declearation of the same name in same scope
{
    a:7 // new overriding previous declearation in the sub block scope
}
// unused variable: warning in dev mode, error in prod mode

```

new design as pattern match
```S
// type is a set of rule for value, it defines the representation of value, the layout of memebers, the range of the values.
// : is ofType operator, used to constrain the obj value, 
// = is asignment(valueDePattern) operator
a:1i32 // a is of the pattern of value 1i32, means it can only be 1i32, it's type is 1i32, it's 4 bytes of signed integer encording and with the value of 1
aa:i32 = 1 // 1 do patter match into var aa, it is ofType i32, to make it success, 1 is i32
bb:=8i32 // declear new var with same type(i32) as the assigned value(8)
// pattern match explaining
bb:i32 = 8i32
variable pattern(bb), then type pattern(i32)

// pure declearation 
bb:i32 // imutable var bb

// = (assigment operator, depattern) 
// used for init (first mut) or mut the value.
bb = 1 

a_ = 2

// one line
a:int b:=2 c:=3

//// = used in function default value too
// default use : too
b:f64 = a // implicit value converter

// explicit value converter
//`c = a as f64 // as is not good for b+c as f64, is it for c or b+c
`c = f64(a)
// : is new and init
// let a // declear a variable with its type infered by following usage.
// `a not needed
// declear and assignment
a:=7i32 //declear a and 7 is initial value: a:i32, type is infered
// := operator is used for content assignment
b_=5i33
b_=4
// have to be decleared before assign
c=4i32// error:  not decleared
a = 6i32 ; A=5 // assignment to an already declared  uninitialized variable or mutate a initialized mutable variable

// allow variable overriding
a=3 // declear a, if not exist, otherwise modify it. 3 is int if not 3i64
a := 3 // declear a new var 
a=6 // error: override the  declearation with a new declearation of the same name in same scope
{
    a:=7 // new overriding previous declearation in the sub block scope
}
// unused variable: warning in dev mode, error in prod mode

```
## Operator
### Bit Operators
```S
the c bit operators are replaced, we want to use these operator for other grammer: https://en.wikipedia.org/wiki/Bitwise_operations_in_C#Bitwise_operators
&	bitwise AND
|	bitwise inclusive OR
^	bitwise XOR (exclusive OR)
<<	left shift
>>	right shift
~	bitwise NOT (ones' complement) (unary)
```
```S
& : and
| : or
^ : xor
<< : lShift
>> : rShift
~ : not
```
```S
/ : return f64
//: floor int, need? same as double.floor()
/\: ceiling int, need? same as double.ceiling()
6/4 as int32 //  
```
## visibility
```S

```

## Identifier(Variable/Function Name) Rule
```S
// Type name start with Big case
// variable or member(field function) start with small case
// mutable: end with '_'
// private member start with '_'
type Ad(a_:int) { 
    b_: 4
    _d_: 5 // private mutable
    ce:f32
    func_(a:int)->nil {b_=a+ce}
}
// 
```
### imutable, mutable and const
```S
const CONST_GLOBAL:mustInitiallizedWithCompileTimeConstExpression // implicitly imutable, static lifetime
a:anyExpressionIncludeRuntimeValues // explicityly imutable, same life time as the enclosing scope

A:i32 // mutable variable in scope is upcase
// s allow global runtime variable, rust has static variable, it's compile time global variable
// S constrain global variable/const with BIG_CASE_NAME, otherwise a compile time error

```

### lazy initialization
```S
lazy a: runtimeExpressionExecutedWhenFirstTimeUsing
//  avoid paying the initialization cost when the program starts if they won't be needed.
```
### reference

## flow control
### conditional expression
```S
condition?expression
condition?expression~expression
```
?: isTrue operator
::  isFalse operator

this design compatbale with ?: expression
```S
// problem can not use declear assignment inside ?:
b:3
{
     a > 1 
     ? b:5 // thinking ':' as else instead of init
     : 4 // errer: unpaired ':'
 }
 
 
// solution use `~` as else instead of the `:`.
// another solution is use := as the init operator, 
// so we can continue using `:` as the else operator,
// but we realy like the concise of the `:` as the init operator, just like we use it in the type constructor
// the dragback: the bitlogic operator of ~ can not be used, 

// maybe we can still use the `:` as the isFalse operator, because if the b is bind, but it is not used. if wanting use it then it is more than one expression, `{}` would be used.

// let's continue use the `:`, and `~` as a backup.

// if we use `~`, we can
Path.exists(path) ~ Os.makeDir(path)
// no, we can not do it! because the else operator is associated with the previous `?`, but we can introduce a `!?` operaotor 
```

```S
   condition 
   ? isTrue expression arm
   : isFase expression arm
```
```S
   if(a>100){}
   a>100?{}
   if(a>100){}else if(a<10){}else{} // 32 chars
   a>100?{}:a<10?{}:{} // 19 chars
   
 a>100
 ? {} // isTrueArm
 : a<10 // isFalseArm
     ? {} // isTrueArm
     : {} // isFalseArm
     
```
```S
 a>100?
 {
 
 }: b>10?
 {
 
 }:
 {
 
 }
 // better
  a>100 ?{
 
 }
 : b>10?{
 
 }
 :{
 
 }
```
```S
c_:4;a_:3;b_:5;
{b_++;a_+=2;a_+b_+c_ < 20}?
   c_++\
```


 ```S

 // the ?: must com in pair, otherwise: what is the : associate with?
a>100 
? b<2 
? 3
: 4
// is it:
a>100 
? b<2 
    ? 3
    : 4
// or
a>100 
? b<2 
    ? 3
: 4

// if else has similar problem
if(a>100) if(b<2) 3 else 4

// the problem is we allow if without the 'else'
// to solve this problem
// always pair the ? with :, and the empty : when no else

// anothor way
?condition{true_arm}: false_arm

// the it will be
a>100 
? b<2 
    ? 3:
: 4
// but it also has problem
a>1?3:
b:3+4
// solution is pair : with ;


 ```
### loop
#### S loop expression

```S
condition?   // precondition
expression\; // \: loop operator

expression
\condition; // post condition

condition? 
expression
\condition; // post condition

i=1; b=2

// while:
k= i++<10 ? {
    b+=2;
    b>6 ? break 7;
}\;

// do while:
k= {
    b+=2;
    b>6 ? break 7 : yield b
}\i++<10;

// constant loop
k={
b+=2
b>6?break 7
}\

k=i++<10？b++\;

```
loop expression may return 2 type of objects, enumerable, value or both.
### enumeration expression
> not use this design: it requires space before afert %, we chose the design of implicit variable $, $i

```S
   IEnumrable %v 
         expression
         
  IEnumrable i%v 
         expression
         |>expression
         |>expression
                    
               
```   
`return`, `yield`, `continue` and `break` in expression:
  * `break`: break the loop
  * `continue`: end this loop, and continue next loop
  * `yield`: yield one value to the result enumrable, and continue excution. we could yield several value to the result in one loop.
  may return: res, (res, list), list 
  the compiler will know
  
  
  
  * `return`: return of the parent function
  * `yield return`: yield value to parent function. used for enumeratable computation. lazy enumeration , because it's func that called mutiple times
  
  for simple for loop
```js
  for(int i=0;i<100;i++) {}
  for(int i=0;i<100;i=i+2) {}
  for(let a of enumberable) {}
  for(let i,a of enumberable){}
```
> $v is current value
> $i is current index

> $l , $r when write custom code for expression, left and right
```S
0..100 % {/*$v*/}
0..2..100 % {/*$v*/}
enumberable % {/*$i, $v*/}

//we reserve the @ for @ Bindings in pattern match
//  the math % operator for mod , overload it for ienumerable.
// contex for operator: $v, $i, $l, $r
```

### Implicit var
```S
IEnumrable % $i>7?$$
```

## function
### signature
```S
func: (a:i32,b:i32)->i32 = a+b
// suggars
funcA(a:i32,b:i32)->a*b
funcA1(a:i32,b:i32)->i32 a*b
funcB(a:i32,b:str)->i32 {return 3+5}
funcC(a:i32,b:str)->(c:i32,d:f32) {c = 3; d = 5;}
func(a:i32, b:6, c:"abc", d:f32)-> (r1:i32, r2:f64, r3:str) {}
//? for default param value we can still use ':' vs '='
// we determined to use : for default value:
// simple, intuative, no learning
// in s type and value is different, for uint type use a:|4i32
```
### parameter init when call

```S
// init by position
func(3,d:3.14)
// init by position then name 
func(3,d:3.14)
// init by name
func(3,d:3.14)
a: (1,3,k:5)
func(...a)
func(1,k:3,...a) // just override k, and add positional arguments
```

### return value
```S
// ; is the exoression separator
// just use it when nesasery
// for the last expression in function body, it has special meaning, when added to prevent the last expression value to be used as the return value.

// if not reuturn explicitly,
// the last expression result is the return value
// use `;` to explictly make not return the value
cond ? 1;
a: cond?1;
cond ? 1 // the compile will not return the value if not used

```
### return value designment
```S
// by position
(v1,v2) = func(3,d:3.14)
// by position then name 
(v1,v2:r3) =func(3,d:3.14)
// by name
(r1:, r2:) = func(3,d:3.14)

// design: func1(...)
// () needed even if no argument
// `func arg1, arg2 .property`
// vs
// `fuc(arg1, arg2).property`
//
// `fuc().pro` vs `fuc.pro`
// there may property on fuc obj

func(a:i32, b=3.4f32, ...c)
```
```
: :is of type
->: reuturn as type
=: assign the value
=>: not used
```

### negative result
```S
type None // so we can directly use it, instead of Result.None
type Error(msg: string)
type Result<T> = Some(value:T) | None | Error
```

```S
//func()?? // forward None, panic on error
// func()?! // forward Error, panic on none
func()?! // forward Error and on none
func()??{$n # None?{} | Error?{}} // handle negative result
```

### function signature infer from expression
lambda function: 
s function,
> should we use  '`' instead of the '$'?, it's easier to type

```S
// auto scope to where a function defination is good.
// one line: out most expression 
to deduce the parameters
func1: $0 + 4 * $0 
func11: x,y->x+4y
func2: $0^2+2$1+1
x=>x^2+2x+1
//multiple  line:
${// within the block we will infer out a function
func1($,5,$);
func2($)
}
```
string interpolation we will use % ?

### clousure variables sugar
```S
func(a:i32) -> c:i32 -> a+c
fn1: fuc(3)
// the same as
@[closure(a:3i32)]
fn1(c:i32)->a+c
// 'a' is state variables in the parent scope only for the function
// store states, so the function is not pure.
fn1(4)
```
### pipe operator
https://github.com/tc39/proposal-pipeline-operator
based on the S function



## Type

type is pattern, we use type to define the pattern of value

```S
&: reference to const
&var:  reference to variable

type A(a:i32,b=6.1f32,c="song")
// a's default value is zero of type, here is 0.
// a type is defined with all default value of it's fields.
// a block of mem, with every member accessed by index, but with specific member accessed by name
```

```S
ty A;
memberType is either explicit or defered from defaultValueLiteral
// declear
type Name // desuger into typeName()
type Unit() // we have to use this to define unit type in tagged unin, otherwise it is reference of type defined somewhere.
type Name(i32,str)
type Name(a:i32,b=1.2f32)
// = default value
type Name(i32,str,d:i32,e1.2f64)
Name(3,"fff",d:4,e:7)
//: : of type or init as
//= : assignment or default value
// type alias and part type
type A = B // type alias of B

// use pattern to define part type
type bool = true | false
type F = 3|5|6.2
type C = i32&4 // 
type D = i32&1..=5
type E = i32&<5
type FG = >=60i32
type St = Str&x&&x.incudes('a')
type Colors = Red:0xff0000|Yellow:0xffff00
// enum of rust
type G = A(i32,b=7i64)|D|L(f=6.2F)|U()
// we could not use b:7i64, it's pattern match if b to match 7i64, here b's default value is 7.

 // directly use subtype to define type
 type FFF(a:3..6,b:A|B(i32,f64))
// D is defined some where then use it, if not creat it with D() 

// U is unit type defined here


// construct on stack
`a = Name(1,3)
// access
`b = a.1 // by index
`c = a.c // by name
// construct on heap
a: &Name(1,3)

fn Func1(a:i32, b:3.4, c="yes", d=5u64, e:f64)
// a,e required parameter
// b, c, d: optional parameter with default value
// default value= : value[type]
Func1(3,c="no",e=6.0)
// a is the required parameter can be assigned by position.
// e is the required parameter, after optional parameter, value should be assigned by name.
// assignment rule: position... name...
// 
```

```S
type A<T;b;d> = (a@`c, c@>d, b:T){}
<Type1,Type2...;lvar1,lvar2...;rvar1,rvar2...>
A<i32;`bb;3>(c@`cc)=v
```
### anonymous type
```S
(1,2)
(1,) 
// instead of use (1)
// it is easier to parse
// (1,) + (2,3)
// a: (1,) as Typ
```

### member visibility
```S
// private member (func and field) start with _
tp A(_a:int, b:5i32)
// tp _B() //no such for module level
// we exp at module level explicitly in the mod.s
```
> compatable with function parameter design
> the function can be viewed as an expression with a anonymous type a parameter
### constructor


```S
//requirement: constructor param with default value must after the one without defaut value, otherwise the required paramter after the optonal one can only be assigned via name, means not possible via position
// need this constrain??

A(publicImutable: i32, mutable_: Str, _private: i32, _privateMutable_: [i32], a=5i32, pureParaNotMember:int@para) {
 _privateMemb: i32
 publicMemb: f32
 func(){
 
 }
 {
// init logic
 }
}

// part of A
//part A {
 // only define members, not constructor,  no init logic
 // we can group members here, may be in another file compliler together
//}

// static 
A {
_private:6
pubField: i32
PubFieldOfType: i32
_PriFieldOfType:i32
pubFunc(){}
{
init logic
}
}
```
### Destructor
> via pattern match
```S
(positinalPubMemberInCstorB, optionalPubMemberInCstorC, pubMemberInsideBody: d) = a;
```

### member access
```S
a.1
b.member
// can not 
c.expression
// the location is determined at compile time, name and position is not stored in runtime
// but we can access array with expression, the location is consecutive and every item of same size:
a[expression]
```
### member logic
```S
MemberLogic: {
expression |
function defination
...
}

(
varA:i32,
funcA: (a:i32,b:i32)->a*b,
)
// or give it a name
Type A(
varB: i64,
varA: 3i32,
funcD: a:i32->a*5,
)

type A(a:i32,b=6.1f32,c="song") {
  funcC: (bb:i32,dd:str)->(c:i32,d:f32) {
  // can not just use '.':
  // i.e. 
  // a.b  // user may use a new line for long line
  //  .c //c of b or 'this obj'?
  // so we use $, it's a longs on the column: huabiao
  // another cause: can not use 'this obj' i.e. in str interpolation, in operator overloading
    $.a = bb
    dd = $.c; // access of 
  }
}
// func call: 
a.func()
// the same as
func(a)
// when compiled to C, the first parameter is the $: _s_
// outside the type body

// static function
A.func(){}
```
```S
// extension method of A
func1($: A){}

```

### Property

```S
A(){
    b_: CT { // \n is meaningful, { at the same line 
        ()->$_ // underlie mutable
        v->$_=v; // we use $_ instead of _$
        // $_ only meaningful when used in setter
        
        // ; to prevent value return
        // but it can be removed
        // we know the setter does not return value
    }
    b:CT->3
    
    [i:int]:T{
    v-> {}
    ()->{}
    }
}
$_ is underlie value, if it us not used in getter or setter, S will not create the underlie field
```
```S
b_:{
${$_}
${$_=$0;}// ; to prevent value return
}
```
#### readonly vs imutable
```S
// readonly means can not modify from outside, but can be modified from inside
// imutable means can not modify both from outside and inside
a:Type // imutable
a_:Type// mutable
// readonly
b:Type {()->a_}
```
#### Value Property
```S
type int(value:int{()->$_, v-> $_ = v}) {
}

a:int = 4

```
### operator
```S
type A(){
// us2 exact name can enble operator override
op + (right: A){
    $.add( right -1)
}
}

```

```S
// filr: oprt
exp op + (left:A, right: A){
    left.add( right -1)
}
```
```S
imp oprt.+

```
### Discriminated Unions
```S
DiscriminatedUnions: type TypeName = SubTypeSymbol ('|'SubTypeSymbol)*[{memberLogic}] 
SubTypeSymbol: SubTypeName|Type
[...]: optional repeat

// Type is defined in scope.
for a sybTypeSymbol: if not defined in scope, it's a subtype name and we create a subtype
```
### Unit type

```S
type Red
type Color = Red | Blue | Yellow
// Blue and Yellow is new unit type
// desugur
type Color = Red | Blue() | Yellow()

a: Red
// desugur 
a: Red = Red()

type BinTree = Node(BinTree,BinTree) 
                           | Tip
// tip is not find, desugur into Tip() to creat a new type


```
#### implement
add first field to identify the subtype, 
at compile time alocate a number to identify. 0, 1, 2, ..
the declearion file generated contains info that identify the cororesponding dll

the compiler will check the link, just in case of mismatch.

#### merged type
```S
type A = B+C // A created from B and C, with all the member of B and C
// we do not use &, because it is used for and in pattern match
```

#### compile time  type convert
```S
prism(color: Collor)-> i32 

c: Blue
prism(c)
// details
prism(Color(c))
// Color is a union, need runtime info to discriminate sub type

```
### Funciton Member
```S
type A (a:int32,B:6i32){
    func()->3
}
A.funcA()->4
```

## Array, List, Map and Set
### Array
features: fixed length items of same type stored in the concatunated mem; 
```S
a: i32[] // type
a: i32[3] // value
a:= [1,2,3]i32[]
a:i32[3] = [1,2,3]
// the array's capacity==length is fixed, 
// like primary types, it is allocated on stack

a: i32[4]_ // imutable array
```
### List
features: variable length items of same type stored in the concatunated mem; 
```S
a:= [i32]() // empty list
a:= List<i32>() // same as above
b:= [1i32, 2, 3]
//
// can avoid realocation if we already know the max capacity

List<T>(cap: i32,  default(T)) {
    len: i32
    _data_: &T // refernce of type T
    free(){} // decrease refCnt and if 0 release the mem on heap
}
// a List var c on stack with mem of 500 i32 on heap {refCnt:usz;500*i32;}
// the refCnt is 1, call the free when free the stack
c: [i32](500) 

```
### array initialize
```S
a: [1,2,3] // array
b:list[1,2,3]
```

###  index range
```S
type Range(startIndex: i32, stopIndex: i32, stepSize: i32 = 1)
a: [1,2,3,4]
1..=4 // 1,2,3,4
1..4 // 1,2,3
'a'..='z'
0..=-1
..
-1..0 // step size -1
a[-1..=0] // [4,3,2,1]
1..2..8 // 1,3,5,7
1..2..=8 // 1,3,5,7,8
'a'..'e' // a, b,c,d
```
### list comprehension
```python
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x for x in fruits if "a" in x]
```

```S
[...(fruits% 'a' ^ $$ ?$$)]

// creat a list 
[fruits% 'a'^$$ ?$$]

// variable pattern and in pattern
//[...(fruits% #x&('a' in x) ?x)]
// variable pattern and 'and' condition
[...(fruits% $$#x&&(x.include('a')) ?x)]
```
### content operator
```S
:= : content assignment
// can not use :+ and :-, collide with initiate with number

// content add: insert, append, prepend
// should use += instead the design of :< (append) >: (prepend)

+=(left:collection<T>, right:(itemPattern: Pattern, index:int32, times: int32))

str += 'c' //content append
queue += msg 
+= ItemOrIenumrable<Item>,index:-1, times: 1  return enumerable
str += 'a' += 'b'
//+= insert
str += 'c',0 // prepend
// >: prepend // i=0
str += 'c',times:5 //"ccccc"

// content extract: remove, pop, dequeue
str:> : remove all

-=:  item:_, index: -1, times:1
 -=(left:icollection<T>, right:(item:&T, index:int32, times:int32))
// item is a pattern match
// return modified collection
a: queue-=&b,0 // dequeue
a: stack-=&b // pop
// clear
collection -= times:-1

// str <: c // dequeue

str := "ggg"
it>>col // prepend
col<<it // append
```

## Set
```S
a: [1,2,3]set
```
## Map
```S
[(str,i32)]
typ Map<K, V>()
// 
a: [(i32,f32)] = [(1,3.2), (4,6.7)]
b: [(1|2,f32)] = [(1,3.2), (2,3.3)]
```



## Interface
```S
inf A()
{}
```

## Module
in file 
```S
imp filePath, directoryPath
typ A() // exported
typ _B() // not exported
```
in mod.s of folder
```S
imp childFile, childFile1, ChildFile2
exp childFile.A, childFile1.{B,C}, childFile2.*
eip childFile.* // export imported

```
## GC
S use reference counter to trance obj life time on heap,
when allocated on stack the owner is the stack, the function will unwind the stack so the lifetime of the stack allocate obj is defined with the `{}` scope

when a object is allocated on heap, the owner is the heap.
```S
{
// `&` to allocate obj on heap
a := &Str('abc') 
// an addtional field refCounter:int will be append to the obj on heap and the value is 1, because the ':=' assigned it to a var `a`
{
b:=a // asigned to b, a is sitll alive and the counter is 2 now
}
// the counter is 1 now
log.info("$a")
// the counter is 0 and the obj is freed from heap
// at the end of the scope inject logic to decrease counter of heap reference var.
}
```

implement the IResource interface to free resource when obj's life time is ending (from stack or heap)
```S
inf IResource(){
    free()
}

type Socket(){
    conn: connection
    free(){
        conn.free()
    }
}
```



## DI
```S
// no global variable
$app.container = [(InfA1, A(1)),(InfB1, B(1))]
```
## Type Matching

> type matching: recognize the pattern, mach the value to it and return a bool
```S
// ` is the new (creating) syntaxor
`A<TList;lvarList;rvarList> patterns(memberPatterns){member logic and function}

// : is the ofType syntaxor
a:A // ` is not needed when :
a,b:i32 c = 2i32 // = is the assignment syntaxor which do type matching and throw if not matching
`C(a:u32, b=i32){

}

// B is a special T with m>c, p==a
`B<T;a;c,d> T(m:>c,o:b, p:==a) {

}

bb: B<A;`aa;3,4>

```

example:
```S
a#[a,b]?expression
recognize pattern: collection pattern, length >= 2
match: a is the first, b is the last
a#[b,c,len:5] length == 5, literal pattern

a:[i32:i32]()// empty map

```

### destruction when assignment
> it's pattern match statement

```S
// patternWithVariable = valueExpression
// compiler error if the pattern is not match
```
#### variable initiallization or assignment in pattern
```S
(a, b:c, d=e) = h 
// new variables: a, c. e is a previously decleared varaible, 
// a is by position new variable is the same as :a; ':a' is explicitly new by position, '=a' is explicatly assigment by position
// a: is a:a; b= is b=b
```
```S
// by position
(0:b,4=c,5..10:a)=d
```
```S
// pattern match
(x:_): a type with a member named as x
(x:_,len:1): a type with a member named as x
(x): a type with first member and assigned to x
(x,len:1): a type with only one element, and match it to variable x
```
    

### pattern match operator
> it's pattern match expression

```S
// variable#pattern
// #: pattern match operator that return booleanValue

b: variable# (a,c) // return boolean if match, and when matched, assign value to a,c
// try to match to the type that has 2 items; a: first item in type; b: second item in type;

```

```S
type Some(i32)
let num = Some(4)
a: num#Some(x)&&x%2==0?x:-1
```

#### pattern match with case-arms
 ```S
a #>100&x && x==900?{};   
a #>100?{}|<10?{}~{}
```

```
 v  #pattern   ?if expression arm
    |pattern   ?{if code block expression arm}
    |pattern   ?if expression arm
    |pattern LogicConditionExpression  ?if expression arm
    ~else expression arm
```  
  
```S
   var usually is a discriminated union defined with '|'
   |: discrimination case or: continue pattern match for var, == '~var#'
   ?: condition?expression: if expression operator
   :: else expression operator
   ;: expression end symbol: end of the pattern match without else
   && and ||: lazy boolean expression operator
   & and |: 'and' and 'or' pattern mach oparator
```
### enumrable pattern match
```S
//IEnumrable [i]%[v]#pattern ... 
// 
   IEnumrable % #pattern ? expression
               |pattern ? expression
               |pattern ? expression
               ~expression
 //expand to
  IEnumrable i%v v#pattern ? expression
               |pattern ? expression
               //|a @ pattern ? expression
               |pattern & a ? expression
               //|Type(c:v@1..=8)? v++
               |Type(c:1..=8 & v)? v++
               ~expression  
```

### # operator vs = operator
```S
func(...) # (a,(c:d))
// unmamed struct (tupple) pattern, variable pattern
created 2 variables
It's a pattern match expression returned bool, but not used
// a and d is new variable
// : is the as operator to creat a new variable and assign initial value
// =  is operator to assign a value to variable already created.
// we first call then use the value, easy to input and support fluent intelligence, mind model, but it accept match fail, if input is not matching


(a,(c:d)) = func(.....)
// do pattern match if false throw
// '=' assignment match which guards the right destruction with compile time for type match, and runtime value match.

```

### patterns
#### continuing pattern ' '
just continuing writing following patterns add space if needed

> note: the '&' is the 'and' pattern syntaxor
> currently continuing is the same as &

~~prority: &>|>continuing~~
```S

`a: >3<5|>10<20
//it's not  >3(<5|>10)<20
`b: <5|>10&<20
```

```S
`a i32 >3 = 5 
// same as above, ' ' is not needed, 
`a i32>3 = 5
```

below not used which using ':' as continue
```S
pattern: =`initNewVar
//pattern = setMutVar
pattern:mutVar
`a: i32 = 5
`b: >=5i32 = 10
`b >=5i32 = 10 // no need :
```
#### new var pattern `
```S
x = value // variable pattern and assign value to existing var x
`x= value // variable pattern and create var x with same type as the value
```

```S
// fluent thought
// return the var
value # `var // var pattern to new var
value # var // var pattern to exit var

// return the var
var = value // var pattern to exist var
var : value // var pattern to new var
```

#### Type Pattern
```S
//: is the ofType syntaxor
`x:X = a // variable pattern then type pattern
```

#### typeName patterns
```S
:A
:A=`a =b// init new var a
A = a // set a
```
> when in assignment, checked in compile time
#### key pattern
find the key from context

> position key

```S
b:i32
d:i8
//
// (:=a, =b, 4:=c, 6=d, 7=>=8)= pp
// (`a, b, 4:`c, 6@==d,7@>=8)= pp
  (`a, b, 4:`c, 6:==d,7:>=8)= pp
```
> member key pattern
```S
b:i32
//(a:=x, b=z)
//(a@=`x, b@=z, d.e@5)
(a:=`x, b:=z, d.e:5)
 A.b.c: 8 // type A with property b that has proterty c
```

##### Value member pattern
require the member to have a `value` or `value_` memeber
```S
int&3 // type pattern and literal pattern
// the value memeber pattern:
int(value:3)
``` 
#### refence pattern
```S
type A(a:i32, b:&i32){
}
// '&' allocate value '3' on heap
`aa=A(2,&3)
`c = 3i32

// & is the reference pattern
// '&pattern' will treat the value of b as the address and get the value from the address, then do futher pattern match with the value.
(a#`b, b#&c) = aa 


```

##### List pattern design
> Set | List {index}:Collection(count):IEnumrable
```S
`aa
[a,b,4..^4@c,w,..:f,6:d,e,aa,=aa]
// the position is determined by the previous item position, 
// if the previous item is a range, the end of the range is used
// if it's a '..' full range, we need to explicitly set the position
// or for simplicity, if the previous is a range we need to set the position explicitly
```
  fix every position
   any object that has
  // i() index pattern, not needed, since the ':' is only for property,var and index ranage
  patternMatch(pattern:str):bool

> we can consider regex to apply to list

#### value pattern
> when the value is know, checked in compile time.
> otherwise checked in run time
#### literal value pattern
```S
//1 // ==1
=1
//2i32 // == 8i32
=2i32
//2|3 // ==2|3
=2|=3
```
~~because it's literral pattern, we can remove the '=='~~

#### relational pattern
> `>, <, >=, <= != =value literal`
```S
A(m:>=5)
!B(n:5)
B(n:5)
// if use = as `==`
// `a=b=15
`a==b = 15
```

> ~~no == with do literal match, because we directlay use he literal value pattern
> but we need it when compaire with variable, otherwise it's assignment to the variable~~
```S
v:i32, d:3
(a@=c,b@d,c@=d) = (a=1,b=2,c=3)
```


> we use `:!` to do !=
```S
//v=4 = a
 v==4 = a
v!=4 = a
4 = a
```
> `!` is the inverte pattern, that means the invert of the following pattern matching

> only compair  value literal, to compair with variable
(a:x) && x>b
#### logical pattern
> !: not, &: and; |:or
> : is also the 'and', but with low precedence, it can only be used after property, variable, and index range pattern.
precedence: : < | < &
```S

```
#### in range pattern
the literal range

```S
//in(1..7)
//in('a'..='z')
^1..7
^'a'..='z'
```


### check function parameter via pattern match
```S
func(a:int>5, b:Str!nil)
```
> c# has a deprecated proposal to use !! to checking parameter null, which is a bad design.

## Compile Time Reflection

```S
a=type(A)
a.name
a.fields
a.staticFields
```
## DI


compile time di
```S
c:[( // banana in the box
Ta: 5,
IB: Tc,
Y: ()->7
)]
// pass in a container to construct D, it will also trigger the chain of constructor via the container
D(c)

```
chaining and overriding
```S
cc:[(
...c, // overriding
Y: 8
)]

f:[(B:7)cc] // f extends cc
```

in S we do not have global variable, we support similar requirement via DI, but because the di value is passed in via constructor function, the primary value is just a copy of the value in DI, to modify it we need share it via reference:
```S
[(
&int ->&int(3)
)]
```
tagged type
```S
c:[(
int@Tag -> 3,
@TagA-> 4 // any type of TagA
)]

type B(int`Tag)
B(c)
```
type patter in container

```S
// only type pattern allowed, compile time pattern
[(
A-> 3 // type A
(n:_)-> 4 // any type with property n
(2:int:_)-> 7 // any type with paramter index 2 is a int type
(b.c:_)->8 // any type with property b that has property c
A($a)-> 4 // a member of type A
)]
```

## Lib
### Log
by defaut write to console
```S
type Log(){
    info(msg:str, newLine:false)
}
```


